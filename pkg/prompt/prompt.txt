Project structure
.
├── cmd
├── docs
│   └── Forme.md
├── go.mod
├── go.sum
├── internal
├── pkg
│   ├── cronyx
│   │   ├── delivery
│   │   │   └── console.go
│   │   ├── embed-example
│   │   │   ├── data.csv
│   │   │   ├── main.go
│   │   │   └── sample.md
│   │   ├── engine.go
│   │   ├── interfaces.go
│   │   ├── job.go
│   │   ├── loaders
│   │   │   └── csv.go
│   │   ├── outputs
│   │   │   └── filegen.go
│   │   └── renderers
│   │       └── markdown.go
│   └── prompt
│       └── prompt.txt
└── README.md

12 directories, 15 files

engine.go 

package cronyx

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/robfig/cron/v3"
)

type Engine struct {
	cronSched  *cron.Cron
	Loaders    map[string]DataLoader
	Renderers  map[string]TemplateRenderer
	Outputs    map[string]OutputGenerator
	Deliveries map[string]DeliveryAdapter

	jobQueue chan ReportJob
	workers  int
	stopCh   chan struct{}
}

func NewEngine(workers int) *Engine {
	e := &Engine{
		cronSched:  cron.New(cron.WithSeconds()),
		Loaders:    map[string]DataLoader{},
		Renderers:  map[string]TemplateRenderer{},
		Outputs:    map[string]OutputGenerator{},
		Deliveries: map[string]DeliveryAdapter{},
		jobQueue:   make(chan ReportJob, 100),
		workers:    workers,
		stopCh:     make(chan struct{}),
	}
	return e
}

// Register helpers:
func (e *Engine) RegisterLoader(name string, d DataLoader) {
	e.Loaders[name] = d
}

func (e *Engine) RegisterRenderer(name string, r TemplateRenderer) {
	e.Renderers[name] = r
}

func (e *Engine) RegisterOutput(name string, o OutputGenerator) {
	e.Outputs[name] = o
}

func (e *Engine) RegisterDelivery(name string, d DeliveryAdapter) {
	e.Deliveries[name] = d
}

// Start scheduler/workers
func (e *Engine) Start() {
	for i := 0; i < e.workers; i++ {
		go e.workerLoop(i)
	}
	e.cronSched.Start()
}

// Stop
func (e *Engine) Stop() {
	ctx := e.cronSched.Stop()
	select {
	case <-ctx.Done():
	case <-time.After(2 * time.Second):
	}
	close(e.stopCh)
}

func (e *Engine) AddCronJob(job ReportJob) error {
	if job.Schedule == "" {
		return errors.New("empty schedule")
	}
	// enqueue on schedule
	_, err := e.cronSched.AddFunc(job.Schedule, func() {
		e.jobQueue <- job
	})
	return err
}

func (e *Engine) Enqueue(job ReportJob) {
	e.jobQueue <- job
}

func (e *Engine) workerLoop(id int) {
	for {
		select {
		case job := <-e.jobQueue:
			ctx, cancel := context.WithTimeout(context.Background(), job.Timeout)
			_ = e.execute(ctx, job)
			cancel()
		case <-e.stopCh:
			return
		}
	}
}

func (e *Engine) execute(ctx context.Context, job ReportJob) error {
	// 1. find loader (based on type in DataSource)
	dsType := job.DataSource["type"]
	loader, ok := e.Loaders[dsType]
	if !ok {
		return fmt.Errorf("no loader for type %s", dsType)
	}

	// 2. load
	data, err := loader.Load(ctx, job.DataSource)
	if err != nil {
		return err
	}

	// 3. render (pick renderer from template type; we'll assume "markdown")
	renderer := e.Renderers["markdown"]
	rendered, err := renderer.Render(ctx, job.TemplatePath, data)
	if err != nil {
		return err
	}

	// 4. outputs
	var files []OutputFile
	for _, fmtName := range job.Outputs {
		outGen, ok := e.Outputs[fmtName]
		if !ok {
			return fmt.Errorf("no output generator for %s", fmtName)
		}
		f, err := outGen.Generate(ctx, rendered, fmtName)
		if err != nil {
			return err
		}
		files = append(files, f)
	}

	// 5. delivery
	for _, dCfg := range job.Delivery {
		dtype := dCfg["type"]
		adapter, ok := e.Deliveries[dtype]
		if !ok {
			return fmt.Errorf("no delivery adapter for %s", dtype)
		}
		if err := adapter.Deliver(ctx, dCfg, files); err != nil {
			return err
		}
	}

	return nil
}

func (e *Engine) GetLoaders() map[string]DataLoader {
	return e.Loaders
}

func (e *Engine) GetRenderers() map[string]TemplateRenderer {
	return e.Renderers
}

func (e *Engine) GetOutputs() map[string]OutputGenerator {
	return e.Outputs
}

func (e *Engine) GetDeliveries() map[string]DeliveryAdapter {
	return e.Deliveries
}

func (e *Engine) TestExecute(ctx context.Context, job ReportJob) error {
	fmt.Printf("=== Executing job: %s ===\n", job.Name)

	// Add timeout to context
	ctx, cancel := context.WithTimeout(ctx, job.Timeout)
	defer cancel()

	return e.execute(ctx, job)
}

interfaces.go 

package cronyx

import "context"

// DataLoader loads raw data for a job.
type DataLoader interface {
	// Load returns data in a canonical form (e.g., []map[string]interface{} or bytes)
	Load(ctx context.Context, cfg DataSourceConfig) (DataPayload, error)
}

// TemplateRenderer: given template + data returns rendered HTML and/or structured doc.
type TemplateRenderer interface {
	Render(ctx context.Context, tplPath string, data DataPayload) (RenderedDoc, error)
}

// OutputGenerator: takes rendered docs to produce final files (pdf, xlsx, csv)
type OutputGenerator interface {
	Generate(ctx context.Context, rendered RenderedDoc, format string) (OutputFile, error)
}

// DeliveryAdapter: delivers file(s) to a target (email, slack, s3)
type DeliveryAdapter interface {
	Deliver(ctx context.Context, target DeliveryConfig, files []OutputFile) error
}

// Minimal data structures
type DataPayload struct {
	// generic bag — implementers decide representation
	Rows []map[string]interface{}
	Raw  []byte
}

type RenderedDoc struct {
	HTML    string                 // for HTML→PDF pipelines
	Content string                 // raw content
	Meta    map[string]interface{} // metadata
}

type OutputFile struct {
	Name string
	Path string // local path or s3:// uri depending on storage adapter
	Data []byte // optional
}

job.go 

package cronyx

import "time"

type ReportJob struct {
	ID           string
	Name         string
	TemplatePath string
	DataSource   DataSourceConfig
	Outputs      []string
	Schedule     string
	Delivery     []DeliveryConfig
	Timeout      time.Duration
	Labels       map[string]string
}

// DataSourceConfig is generic; specific loaders will parse it.
type DataSourceConfig map[string]string

type DeliveryConfig map[string]string

console.go 

package cronyx

import "time"

type ReportJob struct {
	ID           string
	Name         string
	TemplatePath string
	DataSource   DataSourceConfig
	Outputs      []string
	Schedule     string
	Delivery     []DeliveryConfig
	Timeout      time.Duration
	Labels       map[string]string
}

// DataSourceConfig is generic; specific loaders will parse it.
type DataSourceConfig map[string]string

type DeliveryConfig map[string]string

csv.go 

package loaders

import (
	"context"
	"encoding/csv"
	"github.com/Nyxox-debug/Cronyx/pkg/cronyx"
	"io"
	"os"
)

type CSVLoader struct{}

func (c CSVLoader) Load(ctx context.Context, cfg cronyx.DataSourceConfig) (cronyx.DataPayload, error) {
	path := cfg["path"]
	f, err := os.Open(path)
	if err != nil {
		return cronyx.DataPayload{}, err
	}
	defer f.Close()

	r := csv.NewReader(f)
	headers, err := r.Read()
	if err != nil {
		return cronyx.DataPayload{}, err
	}
	var rows []map[string]interface{}
	for {
		record, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			return cronyx.DataPayload{}, err
		}
		row := map[string]interface{}{}
		for i, h := range headers {
			row[h] = record[i]
		}
		rows = append(rows, row)
	}
	return cronyx.DataPayload{Rows: rows}, nil
}

filegen.go 

package outputs

import (
	"context"
	"fmt"
	"github.com/Nyxox-debug/Cronyx/pkg/cronyx"
	"io/ioutil"
	"os"
	"path/filepath"
	"time"
)

type FileOutputGenerator struct {
	OutDir string
}

func (g FileOutputGenerator) Generate(ctx context.Context, r cronyx.RenderedDoc, format string) (cronyx.OutputFile, error) {
	// Create output directory if it doesn't exist
	if err := os.MkdirAll(g.OutDir, 0755); err != nil {
		return cronyx.OutputFile{}, fmt.Errorf("failed to create output directory: %w", err)
	}

	// Generate filename with timestamp
	timestamp := time.Now().Format("20060102_150405")
	filename := fmt.Sprintf("report_%s.%s", timestamp, format)
	outPath := filepath.Join(g.OutDir, filename)

	var data []byte
	switch format {
	case "html":
		data = []byte(r.HTML)
	case "pdf":
		// Placeholder - in production, use a PDF generator
		data = []byte(r.HTML)
	case "md":
		// Extract original markdown if available, otherwise convert HTML back
		data = []byte(r.HTML)
	default:
		data = []byte(r.HTML)
	}

	if err := ioutil.WriteFile(outPath, data, 0644); err != nil {
		return cronyx.OutputFile{}, fmt.Errorf("failed to write output file: %w", err)
	}

	return cronyx.OutputFile{
		Name: filename,
		Path: outPath,
		Data: data,
	}, nil
}


markdown.go 

package renderers

import (
	"bytes"
	"context"
	"fmt"
	"github.com/Nyxox-debug/Cronyx/pkg/cronyx"
	"io/ioutil"
	_ "strings"
	"text/template"

	bf "github.com/russross/blackfriday/v2"
)

type MarkdownRenderer struct{}

func (MarkdownRenderer) Render(ctx context.Context, tplPath string, data cronyx.DataPayload) (cronyx.RenderedDoc, error) {
	// Read template file
	b, err := ioutil.ReadFile(tplPath)
	if err != nil {
		return cronyx.RenderedDoc{}, fmt.Errorf("failed to read template: %w", err)
	}

	// Create template
	tmpl, err := template.New("report").Parse(string(b))
	if err != nil {
		return cronyx.RenderedDoc{}, fmt.Errorf("failed to parse template: %w", err)
	}

	// Prepare template data
	templateData := map[string]interface{}{
		"Rows": data.Rows,
		"Data": data.Rows, // alias for convenience
	}

	// Execute template
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, templateData); err != nil {
		return cronyx.RenderedDoc{}, fmt.Errorf("failed to execute template: %w", err)
	}

	// Convert markdown to HTML
	html := string(bf.Run(buf.Bytes()))

	return cronyx.RenderedDoc{
		HTML: html,
		Meta: map[string]interface{}{
			"source":     tplPath,
			"rows_count": len(data.Rows),
		},
	}, nil
}


data.csv 

name,value,category
Product A,150,Electronics
Product B,200,Clothing
Product C,75,Books
Product D,300,Electronics

embed-example main.go 

package main

import (
	"context"
	"fmt"
	"log"
	"time"

	cronyx "github.com/Nyxox-debug/Cronyx/pkg/cronyx"
	deliver "github.com/Nyxox-debug/Cronyx/pkg/cronyx/delivery"
	loader "github.com/Nyxox-debug/Cronyx/pkg/cronyx/loaders"
	generate "github.com/Nyxox-debug/Cronyx/pkg/cronyx/outputs"
	render "github.com/Nyxox-debug/Cronyx/pkg/cronyx/renderers"
)

func main() {
	// Create engine with 4 workers
	eng := cronyx.NewEngine(4)

	// Register components
	// NOTE: Add other methods
	eng.RegisterLoader("csv", loader.CSVLoader{})
	eng.RegisterRenderer("markdown", render.MarkdownRenderer{})
	eng.RegisterOutput("html", generate.FileOutputGenerator{OutDir: "./out"})
	eng.RegisterDelivery("console", deliver.ConsoleDelivery{})

	// Define job
	job := cronyx.ReportJob{
		ID:           "job1",
		Name:         "daily-sample",
		TemplatePath: "sample.md",
		DataSource:   cronyx.DataSourceConfig{"type": "csv", "path": "data.csv"},
		Outputs:      []string{"html"},
		Schedule:     "@every 10s",
		Delivery:     []cronyx.DeliveryConfig{{"type": "console"}},
		Timeout:      30 * time.Second,
	}

	// Test job execution once
	fmt.Println("=== Testing job execution ===")
	ctx := context.Background()
	if err := eng.TestExecute(ctx, job); err != nil {
		log.Printf("Job execution failed: %v", err)
		return
	}

	// Add to cron scheduler
	if err := eng.AddCronJob(job); err != nil {
		log.Printf("Failed to add cron job: %v", err)
		return
	}

	// Start engine
	fmt.Println("Starting Cronyx engine...")
	eng.Start()

	// Run for 1 minute then stop
	time.Sleep(1 * time.Minute)

	fmt.Println("Stopping engine...")
	eng.Stop()
}

sample.md 

# Daily Report

Generated on: {{.Meta.timestamp}}

## Data Summary

Total records: {{len .Rows}}

{{range .Rows}}

- **{{.name}}**: {{.value}}
  {{end}}

## Additional Information

This report was generated automatically by Cronyx.
